from airflow import DAG
from airflow.operators.python import PythonOperator, BranchPythonOperator
from airflow.utils.trigger_rule import TriggerRule
from datetime import datetime
import os
import sys
from airflow.utils.dates import days_ago

# Add the parent directory to the system path so that custom modules can be imported :)
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

# Import custom functions from the modules
from modules.generate_starting_prompt import generate_starting_prompts
from modules.fake_review_generator import create_reviews, generate_review_by_keyword
from modules.post_process import clean_review
from modules.detecting_fake_reviews import detect_fake_review

# Default arguments for the DAG
default_args = {
    'owner': 'airflow',
    'start_date': days_ago(0),  # Dynamically set the start date to today
    'retries': 1,             # Number of retries in case a task fails
}

def choose_task(**kwargs):
    """
    Branching function to decide which review generation task to run.
    
    It checks if a 'keyword' was provided in the DAG run configuration.
    - If a keyword exists, it returns the task id for generating a review by keyword.
    - Otherwise, it returns the task id for generating starting prompts.
    """
    dag_run = kwargs.get("dag_run", None)
    keyword = dag_run.conf.get("keyword") if dag_run and dag_run.conf else None
    
    return "generate_fake_review_by_keyword" if keyword else "generate_starting_prompts"

# Define the DAG: name, default args, schedule, and catchup settings
with DAG(
    'fake_review_pipeline',
    default_args=default_args,
    schedule_interval=None,  # Run on demand (no schedule)
    catchup=False
) as dag:

    # BranchPythonOperator to choose the next task based on configuration
    choose_task_operator = BranchPythonOperator(
        task_id="choose_review_generation",
        python_callable=choose_task,
        do_xcom_push=False  # We don't push the result to XCom since we only use it for branching
    )

    # Task to generate a set of neutral starting prompts (e.g., 100 prompts)
    generate_starting_prompts_task = PythonOperator(
        task_id='generate_starting_prompts',
        python_callable=generate_starting_prompts,
        op_args=[100],  # Pass the number of prompts to generate
        do_xcom_push=True
    )

    # Task to generate fake reviews using the starting prompts from the previous task
    generate_reviews_task = PythonOperator(
        task_id='generate_fake_review',
        python_callable=create_reviews,
        # Use XCom to pull the prompts generated by 'generate_starting_prompts'
        op_kwargs={'prompts': '{{ ti.xcom_pull(task_ids="generate_starting_prompts") }}'},
        do_xcom_push=True
    )

    # Task to generate a fake review based on a provided keyword, defaulting to "product"
    generate_review_by_keyword_task = PythonOperator(
        task_id='generate_fake_review_by_keyword',
        python_callable=generate_review_by_keyword,
        # Use the keyword from dag_run configuration if available; otherwise, default to "product"
        op_kwargs={'keyword': '{{ dag_run.conf["keyword"] if dag_run else "product" }}'},
        do_xcom_push=True
    )

    # Task to post-process the generated reviews by cleaning them (limiting to 3 sentences)
    clean_reviews_task = PythonOperator(
        task_id='clean_reviews',
        python_callable=clean_review,
        # Pull the output from either review generation task (if one succeeded)
        op_kwargs={'reviews': '{{ ti.xcom_pull(task_ids="generate_fake_review") or ti.xcom_pull(task_ids="generate_fake_review_by_keyword") }}'},
        do_xcom_push=True,
        trigger_rule=TriggerRule.ONE_SUCCESS  # Trigger if at least one upstream task succeeds
    )

    # Task to detect whether the cleaned reviews are fake using a classification function
    detect_fake_review_task = PythonOperator(
        task_id='detect_fake_review',
        python_callable=detect_fake_review,
        op_args=['{{ ti.xcom_pull(task_ids="clean_reviews") }}'],
        do_xcom_push=False
    )

    # Define task dependencies:
    # First, the branching operator chooses between two review generation approaches.
    choose_task_operator >> [generate_starting_prompts_task, generate_review_by_keyword_task]
    
    # If starting prompts are generated, use them to generate fake reviews.
    generate_starting_prompts_task >> generate_reviews_task
    
    # Once fake reviews are generated (via either method), clean the reviews.
    [generate_reviews_task, generate_review_by_keyword_task] >> clean_reviews_task
    
    # Finally, run the fake review detection on the cleaned reviews.
    clean_reviews_task >> detect_fake_review_task
